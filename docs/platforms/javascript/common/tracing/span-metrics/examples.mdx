---
title: Example Instrumentation
description: "Examples of using span metrics to debug performance issues and monitor application behavior across frontend and backend services."
sidebar_order: 10
---

<Alert>

These examples assume you have already <PlatformLink to="/tracing/">set up tracing</PlatformLink> in your application.

</Alert>

This guide provides practical examples of using span attributes and metrics to solve common monitoring and debugging challenges across your entire application stack. Each example demonstrates how to instrument both frontend and backend components, showing how they work together within a distributed trace to provide end-to-end visibility.

## E-Commerce Checkout Flow (React + Backend)

**Challenge:** Capture end-to-end checkout health and diagnose where time is spent or failures occur across UI, API, payments, inventory, and fulfillment.

**Solution:** Start a client span on the checkout action and continue the trace on the backend with spans for each business step. Add low-cardinality business attributes (no PII) to power span metrics.

**Frontend (React) — instrument the Checkout click handler:**

```javascript
// In your Checkout button click handler
Sentry.startSpan(
  {
    name: "Checkout",
    op: "ui.action",
    attributes: {
      // cart.* values known at click time; prefer minor units + currency
      "cart.item_count": cart.items.length,
      "cart.value_minor": cart.totalMinor, // e.g., cents
      "cart.currency": cart.currency || "USD",
    },
  },
  async (span) => {
    try {
      const res = await fetch("/api/checkout", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({
          // Avoid PII; internal IDs only
          items: cart.items.map((i) => ({ sku: i.sku, qty: i.qty })),
          coupon: cart.coupon || null,
        }),
      });

      if (!res.ok) throw new Error("Checkout failed");
      const data = await res.json();

      // Record server-assigned order id after success
      span.setAttribute("order.id", data.orderId);
      span.setAttribute("payment.provider", data.paymentProvider);
    } catch (error) {
      span.setStatus?.("error");
      Sentry.captureException(error);
    } finally {
      span.finish?.();
    }
  }
);
```

Where to put this in your app:
- In the `onClick` for the checkout CTA, or inside the submit handler of your checkout form/container component.
- Auto-instrumentation will add client `fetch` spans; keep the explicit UI span for business context.

**Backend — instrument each business step:**

```javascript
// Example: Node/Express
app.post("/api/checkout", async (req, res) => {
  await Sentry.startSpan({ name: "Process order", op: "business.logic" }, async (orderSpan) => {
    try {
      await Sentry.startSpan({ name: "Validate cart", op: "validate" }, async () => {
        // validate item availability, pricing, coupon
      });

      const payment = await Sentry.startSpan({ name: "Authorize payment", op: "payment" }, async (span) => {
        span.setAttribute("payment.provider", "stripe");
        // call payment provider
        return { id: "pi_123", status: "authorized" };
      });
      orderSpan.setAttribute("payment.status", payment.status);

      await Sentry.startSpan({ name: "Reserve inventory", op: "inventory" }, async () => {
        // reserve stock in DB or external OMS
      });

      const orderId = await Sentry.startSpan({ name: "Create order", op: "db.write" }, async () => {
        // insert order; return internal id
        return "ord_abc123";
      });
      orderSpan.setAttribute("order.id", orderId);

      await Sentry.startSpan({ name: "Send confirmation", op: "email" }, async () => {
        // enqueue email or call provider
      });

      res.json({ orderId, paymentProvider: "stripe" });
    } catch (e) {
      orderSpan.setStatus?.("error");
      res.status(500).json({ error: "Checkout failed" });
    }
  });
});
```

**How the trace works together:**
- UI span starts on click → fetch carries trace headers → backend continues the trace.
- Child spans highlight where time is spent (validation, payment, inventory, DB, email).
- Span metrics let you track latency percentiles and failure rates by attributes like `payment.provider`, `cart.item_count`.

What to monitor with span metrics:
- p95 duration of `op:ui.action` Checkout by `cart.item_count` bucket.
- Error rate for `op:payment` by `payment.provider`.
- Self time of `op:db.*` spans by table to spot slow queries.

## Media Upload with Background Processing (React + Worker)

**Challenge:** Understand user-perceived upload time vs. server-side processing (scan, transcode, thumbnail) and link the async worker back to the initiating request.

**Solution:** Start a client span when the upload begins; on the backend, create spans for signed-URL issuance, enqueue a job, and instrument worker phases. Propagate trace context via job metadata to stitch the traces.

**Frontend (React) — instrument upload begin and progress:**

```javascript
Sentry.startSpan(
  {
    name: "Upload media",
    op: "file.upload",
    attributes: {
      "file.size_bytes": file.size,
      "file.mime_type": file.type,
      "upload.chunked": true,
    },
  },
  async (span) => {
    try {
      const urlRes = await fetch("/api/uploads/signed-url", { method: "POST" });
      const { uploadUrl, objectKey } = await urlRes.json();

      // Use XHR for progress; fetch is illustrative here
      await uploadWithProgress(uploadUrl, file, (progress) => {
        span.setAttribute("upload.bytes_transferred", progress.bytes);
        span.setAttribute("upload.percent_complete", progress.percent);
      });

      await fetch("/api/uploads/start-processing", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ key: objectKey }),
      });

      span.setAttribute("upload.success", true);
    } catch (e) {
      span.setStatus?.("error");
      Sentry.captureException(e);
    } finally {
      span.finish?.();
    }
  }
);
```

Place this where the user triggers an upload (dropzone onDrop, file input onChange, or explicit Upload button).

**Backend — signed URL, enqueue job, and worker phases:**

```javascript
// Issue signed URL
app.post("/api/uploads/signed-url", async (req, res) => {
  await Sentry.startSpan({ name: "Get signed URL", op: "storage.sign" }, async (span) => {
    span.setAttribute("storage.provider", "s3");
    span.setAttribute("storage.bucket", "media");
    // generate URL
    res.json({ uploadUrl: "https://s3...", objectKey: "uploads/abc.jpg" });
  });
});

// Enqueue processing job and propagate context
app.post("/api/uploads/start-processing", async (req, res) => {
  await Sentry.startSpan({ name: "Enqueue media job", op: "queue.enqueue" }, async (span) => {
    const trace = Sentry.getCurrentScope()?.getPropagationContext?.();
    queue.publish("media.process", { key: req.body.key, trace });
    span.setAttribute("queue.name", "media.process");
    res.json({ ok: true });
  });
});

// Worker
worker.on("message", async (msg) => {
  const parentContext = msg.trace; // restore trace/parent if available
  await Sentry.startSpan({ name: "Process media", op: "worker.job", parentContext }, async (jobSpan) => {
    await Sentry.startSpan({ name: "Virus scan", op: "security.scan" }, async (span) => {
      span.setAttribute("scan.engine", "clamav");
    });
    await Sentry.startSpan({ name: "Transcode", op: "media.transcode" }, async (span) => {
      span.setAttribute("transcode.preset", "720p");
    });
    await Sentry.startSpan({ name: "Thumbnail", op: "media.thumbnail" }, async () => {});
  });
});
```

**How the trace works together:**
- Client span covers upload + API calls; backend spans cover signing and enqueue; worker spans show processing phases.
- Linking the worker trace to the enqueue span maintains end-to-end visibility across async boundaries.

What to monitor with span metrics:
- p90 transcode time by `transcode.preset`.
- Failure counts for `op:security.scan` by `scan.engine`.
- Time-to-ready (sum of worker phases) by `file.size_bucket`.

## Search Autocomplete (debounced, cancellable, cached)

**Challenge:** Users type quickly; you need to debounce requests, cancel in-flight calls, and rely on cache where possible while keeping latency low.

**Solution:** Start a client span for each debounced request; mark aborted requests; on the server, instrument cache lookup, search engine query, and ranking.

**Frontend (React) — instrument debounced search:**

```javascript
let abortController;

async function runSearch(query, debounceMs = 150) {
  clearTimeout(runSearch._t);
  return new Promise((resolve) => {
    runSearch._t = setTimeout(() => {
      if (abortController) abortController.abort();
      abortController = new AbortController();

      Sentry.startSpan(
        {
          name: "Search autocomplete",
          op: "http.client",
          attributes: {
            "query.length": (query || "").length,
            "ui.debounce_ms": debounceMs,
          },
        },
        async (span) => {
          try {
            const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`,
              { signal: abortController.signal }
            );
            const data = await res.json();
            span.setAttribute("results.count", data.results.length);
            resolve(data);
          } catch (e) {
            if (e.name === "AbortError") {
              span.setAttribute("ui.aborted", true);
              span.setStatus?.("cancelled");
              resolve({ results: [] });
            } else {
              span.setStatus?.("error");
              Sentry.captureException(e);
              resolve({ results: [] });
            }
          } finally {
            span.finish?.();
          }
        }
      );
    }, debounceMs);
  });
}
```

Place this in your search input hook/component after applying a debounce.

**Backend — cache, search engine, rank:**

```javascript
app.get("/api/search", async (req, res) => {
  const q = String(req.query.q || "");

  await Sentry.startSpan({ name: "Search", op: "search" }, async (root) => {
    const cacheHit = await Sentry.startSpan({ name: "Cache lookup", op: "cache" }, async (span) => {
      const hit = await cache.get(q);
      span.setAttribute("cache.hit", Boolean(hit));
      if (hit) res.json(hit);
      return Boolean(hit);
    });
    if (cacheHit) return;

    const results = await Sentry.startSpan({ name: "Query engine", op: "external.search" }, async (span) => {
      span.setAttribute("search.engine", "elasticsearch");
      span.setAttribute("search.index", "products_v2");
      span.setAttribute("search.mode", q.length < 3 ? "prefix" : "fuzzy");
      return searchEngine.query(q);
    });

    await Sentry.startSpan({ name: "Rank results", op: "compute.rank" }, async (span) => {
      span.setAttribute("rank.model", "bm25");
      span.setAttribute("rank.version", "2.1");
    });

    res.json({ results });
  });
});
```

**How the trace works together:**
- Each debounced request becomes a client span; aborted ones are marked and short.
- Server spans show cache effectiveness, engine latency, and ranking time.

What to monitor with span metrics:
- p95 latency of `op:http.client` by `query.length` bucket.
- Cancellation rate via `ui.aborted=true`.
- Cache hit rate for `op:cache`.
