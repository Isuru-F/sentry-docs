---
title: Example Instrumentation
description: "Examples of using span metrics to debug performance issues and monitor application behavior across frontend and backend services."
sidebar_order: 10
---

<Alert>

These examples assume you have already <PlatformLink to="/tracing/">set up tracing</PlatformLink> in your application.

</Alert>

This guide provides practical examples of using span attributes and metrics to solve common monitoring and debugging challenges across your entire application stack. Each example demonstrates how to instrument both frontend and backend components, showing how they work together within a distributed trace to provide end-to-end visibility.

## E-Commerce Checkout Flow (React + Backend)

**Challenge:** Capture end-to-end checkout health and diagnose where time is spent or failures occur across UI, API, payments, inventory, and fulfillment.

**Solution:** Start a client span on the checkout action and continue the trace on the backend with spans for each business step. Add low-cardinality business attributes (no PII) to power span metrics.

<Arcade src="https://demo.arcade.software/tGYGb3qewR6i4xjRt2Tg?embed" />

**Frontend (React) — instrument the Checkout click handler:**

```javascript
// In your Checkout button click handler
Sentry.startSpan(
  {
    name: "Checkout",
    op: "ui.action",
    attributes: {
      // cart.* values known at click time; prefer minor units + currency
      "cart.item_count": cart.items.length,
      "cart.value_minor": cart.totalMinor, // e.g., cents
      "cart.currency": cart.currency || "USD",
    },
  },
  async (span) => {
    try {
      const res = await fetch("/api/checkout", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({
          // Avoid PII; internal IDs only
          items: cart.items.map((i) => ({ sku: i.sku, qty: i.qty })),
          coupon: cart.coupon || null,
        }),
      });

      if (!res.ok) throw new Error("Checkout failed");
      const data = await res.json();

      // Record server-assigned order id after success
      span.setAttribute("order.id", data.orderId);
      span.setAttribute("payment.provider", data.paymentProvider);
    } catch (error) {
      span.setStatus?.("error");
      Sentry.captureException(error);
    } finally {
      span.finish?.();
    }
  }
);
```

Where to put this in your app:
- In the `onClick` for the checkout CTA, or inside the submit handler of your checkout form/container component.
- Auto-instrumentation will add client `fetch` spans; keep the explicit UI span for business context.

**Backend — single span per request; rely on auto-instrumentation:**

```javascript
// Example: Node/Express
app.post("/api/checkout", async (req, res) => {
  await Sentry.startSpan({ name: "Checkout (server)", op: "http.server" }, async (span) => {
    try {
      // validate, authorize payment, reserve inventory, create order, send email
      const orderId = await createOrder(req.body);

      // Keep attributes low-cardinality and business-focused
      span.setAttributes({
        "order.id": orderId,
        "payment.provider": "stripe",
        "payment.status": "authorized",
        "inventory.reserved": true,
        "email.enqueued": true,
      });

      res.json({ orderId, paymentProvider: "stripe" });
    } catch (e) {
      span.setStatus?.("error");
      res.status(500).json({ error: "Checkout failed" });
    }
  });
});
```

**How the trace works together:**
- UI span starts on click → fetch carries trace headers → backend continues the trace.
- Rely on your SDK's auto-instrumentation for HTTP/DB/external calls; keep this example span simple.
- Span metrics let you track latency percentiles and failure rates by attributes like `payment.provider`, `cart.item_count`.

What to monitor with span metrics:
- p95 duration of `op:ui.action` Checkout by `cart.item_count` bucket.
- Error rate for `op:payment` by `payment.provider`.
- Self time of `op:db.*` spans by table to spot slow queries.

## Media Upload with Background Processing (React + Worker)

**Challenge:** Understand user-perceived upload time vs. server-side processing (scan, transcode, thumbnail) and link the async worker back to the initiating request.

**Solution:** Start a client span when the upload begins; on the backend, create spans for signed-URL issuance, enqueue a job, and instrument worker phases. Propagate trace context via job metadata to stitch the traces.

**Frontend (React) — instrument upload begin and completion:**

```javascript
Sentry.startSpan(
  {
    name: "Upload media",
    op: "file.upload",
    attributes: {
      "file.size_bytes": file.size,
      "file.mime_type": file.type,
    },
  },
  async (span) => {
    const t0 = performance.now();
    try {
      const urlRes = await fetch("/api/uploads/signed-url", { method: "POST" });
      const { uploadUrl, objectKey } = await urlRes.json();

      // Upload file to storage (signed URL)
      await fetch(uploadUrl, { method: "PUT", body: file });

      // Tell backend to start async processing
      await fetch("/api/uploads/start-processing", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ key: objectKey }),
      });

      span.setAttributes({
        "upload.success": true,
        "upload.duration_ms": Math.round(performance.now() - t0),
      });
    } catch (e) {
      span.setStatus?.("error");
      Sentry.captureException(e);
    } finally {
      span.finish?.();
    }
  }
);
```

Place this where the user triggers an upload (dropzone onDrop, file input onChange, or explicit Upload button).

**Backend — single span per handler; single span in worker:**

```javascript
// Issue signed URL
app.post("/api/uploads/signed-url", async (req, res) => {
  await Sentry.startSpan({ name: "Signed URL", op: "storage.sign" }, async (span) => {
    span.setAttributes({ "storage.provider": "s3", "storage.bucket": "media" });
    res.json({ uploadUrl: "https://s3...", objectKey: "uploads/abc.jpg" });
  });
});

// Enqueue processing job and propagate context
app.post("/api/uploads/start-processing", async (req, res) => {
  await Sentry.startSpan({ name: "Enqueue media job", op: "queue.enqueue" }, async (span) => {
    const trace = Sentry.getCurrentScope()?.getPropagationContext?.();
    queue.publish("media.process", { key: req.body.key, trace });
    span.setAttribute("queue.name", "media.process");
    res.json({ ok: true });
  });
});

// Worker
worker.on("message", async (msg) => {
  const parentContext = msg.trace; // restore trace/parent if available
  await Sentry.startSpan({ name: "Process media", op: "worker.job", parentContext }, async (span) => {
    // Do work (scan, transcode, thumbnail) — rely on auto-instrumentation for sub-operations
    span.setAttributes({
      "scan.engine": "clamav",
      "transcode.preset": "720p",
      "thumbnail.created": true,
    });
  });
});
```

**How the trace works together:**
- Client span covers upload + API calls; backend spans cover signing and enqueue; worker spans show processing phases.
- Linking the worker trace to the enqueue span maintains end-to-end visibility across async boundaries.

What to monitor with span metrics:
- p90 transcode time by `transcode.preset`.
- Failure counts for `op:security.scan` by `scan.engine`.
- Time-to-ready (sum of worker phases) by `file.size_bucket`.

## Search Autocomplete (debounced, cancellable, cached)

**Challenge:** Users type quickly; you need to debounce requests, cancel in-flight calls, and rely on cache where possible while keeping latency low.

**Solution:** Start a client span for each debounced request; mark aborted requests; on the server, instrument cache lookup, search engine query, and ranking.

**Frontend (React) — instrument debounced search:**

```javascript
let abortController;

async function runSearch(query, debounceMs = 150) {
  clearTimeout(runSearch._t);
  return new Promise((resolve) => {
    runSearch._t = setTimeout(() => {
      if (abortController) abortController.abort();
      abortController = new AbortController();

      Sentry.startSpan(
        {
          name: "Search autocomplete",
          op: "http.client",
          attributes: {
            "query.length": (query || "").length,
            "ui.debounce_ms": debounceMs,
          },
        },
        async (span) => {
          try {
            const res = await fetch(`/api/search?q=${encodeURIComponent(query)}`,
              { signal: abortController.signal }
            );
            const data = await res.json();
            span.setAttribute("results.count", data.results.length);
            resolve(data);
          } catch (e) {
            if (e.name === "AbortError") {
              span.setAttribute("ui.aborted", true);
              span.setStatus?.("cancelled");
              resolve({ results: [] });
            } else {
              span.setStatus?.("error");
              Sentry.captureException(e);
              resolve({ results: [] });
            }
          } finally {
            span.finish?.();
          }
        }
      );
    }, debounceMs);
  });
}
```

Place this in your search input hook/component after applying a debounce.

**Backend — single span with useful attributes:**

```javascript
app.get("/api/search", async (req, res) => {
  const q = String(req.query.q || "");
  await Sentry.startSpan({ name: "Search", op: "search" }, async (span) => {
    const hit = await cache.get(q);
    span.setAttribute("cache.hit", Boolean(hit));
    if (hit) return res.json(hit);

    const results = await searchEngine.query(q);
    span.setAttributes({
      "search.engine": "elasticsearch",
      "search.mode": q.length < 3 ? "prefix" : "fuzzy",
      "results.count": results.length,
    });

    res.json({ results });
  });
});
```

**How the trace works together:**
- Each debounced request becomes a client span; aborted ones are marked and short.
- The server span shows cache effectiveness and search mode; auto-instrumentation will cover network/DB latency.

What to monitor with span metrics:
- p95 latency of `op:http.client` by `query.length` bucket.
- Cancellation rate via `ui.aborted=true`.
- Cache hit rate for `op:cache`.
