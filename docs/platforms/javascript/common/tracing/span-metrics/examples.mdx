---
title: Example Instrumentation
description: "Examples of using span metrics to debug performance issues and monitor application behavior across frontend and backend services."
sidebar_order: 10
---

<Alert>

These examples assume you have already <PlatformLink to="/tracing/">set up tracing</PlatformLink> in your application.

</Alert>

This guide provides practical examples of using span attributes and metrics to solve common monitoring and debugging challenges across your entire application stack. Each example demonstrates how to instrument both frontend and backend components, showing how they work together within a distributed trace to provide end-to-end visibility. You'll also find example repository code, walkthroughs and attributes to explore.

## E-Commerce Checkout Flow (React + Backend)

<Arcade src="https://demo.arcade.software/tGYGb3qewR6i4xjRt2Tg?embed" />

Example Repository: [Crash Commerce](https://github.com/getsentry/crash-commerce-tracing-sample)

**Challenge:** Capture end-to-end checkout flow, understand average cart size and value, diagnose performance of payment providers across frontend, and server API.

**Solution:** Start a client span on the checkout action for the application, and relevant spans on the backend for each step in the checkout flow. Attach attributes that represent critical metrics for the application, such as cart size and value, and payment provider used in the transaction.

**Frontend (React) — instrument the Checkout click handler:**

```javascript
// In your Checkout button click handler
Sentry.startSpan(
  {
    name: 'Checkout',
    op: 'ui.action',
    attributes: {
      'cart.item_count': cartCount,
      'cart.value_minor': cartValueMinor,
      'cart.currency': 'USD',
      'payment.provider.ui_selected': paymentProvider,
    },
  },
  async (span) => {
    try {
      const response = await fetch(`${API_URL}/api/checkout`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ items: cart, paymentProvider }),
      })
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error: 'Payment failed' }))
        throw new Error(errorData.error || `HTTP ${response.status}`)
      }
      const data: { orderId: string; paymentProvider: string } = await response.json()
      span.setAttribute('order.id', data.orderId)
      span.setAttribute('payment.provider', data.paymentProvider)
      Sentry.logger.info(Sentry.logger.fmt`✨ Order ${data.orderId} confirmed via ${data.paymentProvider}`)
      
      // Show order confirmation
      setOrderConfirmation({
        orderId: data.orderId,
        provider: data.paymentProvider,
        total: cartValueMinor
      })
      setCart([])
      setIsCartOpen(false)
    } catch (err) {
      span.setStatus({ code: 2, message: 'internal_error' })
      const errorMessage = err instanceof Error ? err.message : 'Checkout failed'
      setCheckoutError(errorMessage)
      Sentry.logger.error(Sentry.logger.fmt`❌ ${errorMessage}`)
    } finally {
      setIsCheckingOut(false)
    }
  }
)
```

Where to put this in your app:
- In the `onClick` for the checkout button, or inside the submit handler of your checkout form/container component.
- Auto-instrumentation will add client `fetch` spans; keep the explicit UI span for specific application context.

**Backend — Checkout API with an Order Processing span, and a Payment span:**

```javascript
// Example: Node/Express
app.post('/api/checkout', async (req: Request, res: Response) => {
  await Sentry.startSpan(
    {
      name: 'Order Processing',
      op: 'commerce.order.server',
    },
    async (span) => {
      try {
        const items = (req.body?.items as { productId: string; quantity: number }[]) || []
        const requestedProviderRaw = (req.body?.paymentProvider as string | undefined) ?? undefined
        const requestedProvider = PAYMENT_PROVIDERS.find((p) => p === requestedProviderRaw) ?? pickPaymentProvider()

        // Validate cart
        if (!Array.isArray(items) || items.length === 0) {
          span.setAttribute('payment.status', 'failed')
          span.setAttribute('inventory.reserved', false)
          res.status(400).json({ error: 'Cart is empty' })
          return
        }

        let totalMinor = 0
        for (const line of items) {
          const product = PRODUCTS.find((p) => p.id === line.productId)
          if (!product || line.quantity <= 0) {
            span.setAttribute('payment.status', 'failed')
            span.setAttribute('inventory.reserved', false)
            res.status(400).json({ error: 'Invalid cart item' })
            return
          }
          totalMinor += product.priceMinor * line.quantity
        }

        // Simulate reserving inventory (80% chance true)
        const reserved = Math.random() < 0.8

        // Simulate payment
        const charge = await Sentry.startSpan(
          {
            name: `Charge ${requestedProvider}`,
            op: 'commerce.payment',
            attributes: {
              'payment.provider': requestedProvider,
            },
          },
          async (paymentSpan) => {
            const result = await fakeCharge(totalMinor, requestedProvider)
            paymentSpan.setAttribute('payment.status', result.status)
            return result
          }
        )

        if (charge.status === 'failed' || !reserved) {
          span.setAttribute('payment.provider', charge.provider)
          span.setAttribute('payment.status', 'failed')
          span.setAttribute('inventory.reserved', reserved)
          res.status(402).json({ error: 'Payment failed' })
          return
        }

        const orderId = randomId()
        ORDERS.push({ id: orderId, totalMinor, items })

        // Set attributes before returning
        span.setAttribute('order.id', orderId)
        span.setAttribute('payment.provider', charge.provider)
        span.setAttribute('payment.status', 'success')
        span.setAttribute('inventory.reserved', reserved)

        res.json({ orderId, paymentProvider: charge.provider })
      } catch (err) {
        Sentry.captureException(err)
        res.status(500).json({ error: 'Internal error' })
      }
    }
  )
})
```

**How the trace works together:**
- UI span starts when checkout is selected → Server Backend starts a span to continue the track when the server `/checkout` API is called. As payment processes, a payment span is started.
- Attributes and Span metrics let you track more than just the latency of the request. Can track store busienss performances through `cart.item_count` and other `cart` attributes, and store reliabiliyt by checking error performance on `payment.provider` properties.

What to monitor with span metrics:
- p95 span.duration of `op:ui.action` checkout by `cart.item_count` bucket.
- Error rate for `op:payment` by `payment.provider`.

## Media Upload with Background Processing (React + Worker)

**Challenge:** Understand user-perceived upload time vs. server-side processing (scan, transcode, thumbnail) and link the async worker back to the initiating request.

**Solution:** Start a client span when the upload begins; on the backend, create spans for signed-URL issuance, enqueue a job, and instrument worker phases. Propagate trace context via job metadata to stitch the traces.

**Frontend (React) — instrument upload begin and completion:**

```javascript
Sentry.startSpan(
  {
    name: "Upload media",
    op: "file.upload",
    attributes: {
      "file.size_bytes": file.size,
      "file.mime_type": file.type,
    },
  },
  async (span) => {
    const t0 = performance.now();
    try {
      const urlRes = await fetch("/api/uploads/signed-url", { method: "POST" });
      const { uploadUrl, objectKey } = await urlRes.json();

      // Upload file to storage (signed URL)
      await fetch(uploadUrl, { method: "PUT", body: file });

      // Tell backend to start async processing
      await fetch("/api/uploads/start-processing", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify({ key: objectKey }),
      });

      span.setAttributes({
        "upload.success": true,
        "upload.duration_ms": Math.round(performance.now() - t0),
      });
    } catch (e) {
      span.setStatus?.("error");
      Sentry.captureException(e);
    } finally {
      span.finish?.();
    }
  }
);
```

Place this where the user triggers an upload (dropzone onDrop, file input onChange, or explicit Upload button).

**Backend — single span per handler; single span in worker:**

```javascript
// Issue signed URL
app.post("/api/uploads/signed-url", async (req, res) => {
  await Sentry.startSpan({ name: "Signed URL", op: "storage.sign" }, async (span) => {
    span.setAttributes({ "storage.provider": "s3", "storage.bucket": "media" });
    res.json({ uploadUrl: "https://s3...", objectKey: "uploads/abc.jpg" });
  });
});

// Enqueue processing job and propagate context
app.post("/api/uploads/start-processing", async (req, res) => {
  await Sentry.startSpan({ name: "Enqueue media job", op: "queue.enqueue" }, async (span) => {
    const trace = Sentry.getCurrentScope()?.getPropagationContext?.();
    queue.publish("media.process", { key: req.body.key, trace });
    span.setAttribute("queue.name", "media.process");
    res.json({ ok: true });
  });
});

// Worker
worker.on("message", async (msg) => {
  const parentContext = msg.trace; // restore trace/parent if available
  await Sentry.startSpan({ name: "Process media", op: "worker.job", parentContext }, async (span) => {
    // Do work (scan, transcode, thumbnail) — rely on auto-instrumentation for sub-operations
    span.setAttributes({
      "scan.engine": "clamav",
      "transcode.preset": "720p",
      "thumbnail.created": true,
    });
  });
});
```

**How the trace works together:**
- Client span covers upload + API calls; backend spans cover signing and enqueue; worker spans show processing phases.
- Linking the worker trace to the enqueue span maintains end-to-end visibility across async boundaries.

What to monitor with span metrics:
- p90 transcode time by `transcode.preset`.
- Failure counts for `op:security.scan` by `scan.engine`.
- Time-to-ready (sum of worker phases) by `file.size_bucket`.

## Search Autocomplete (debounced, cancellable, performance monitoring)

Example Repository: [NullFlix](https://github.com/getsentry/nullflix-tracing-sample)

**Challenge:** Users type quickly in search; you need to debounce requests, cancel in-flight calls, handle errors gracefully, and monitor performance across different query types while keeping latency predictable.

**Solution:** Start a client span for each debounced request, mark aborted requests, track search patterns, and on the server, instrument search performance with meaningful attributes.

**Frontend (React + TypeScript) — instrument debounced search:**

```typescript
const response = await Sentry.startSpan(
  {
    op: 'http.client',
    name: 'Search autocomplete',
    attributes: {
      'query.length': searchQuery.length,
      'ui.debounce_ms': DEBOUNCE_MS,
    },
  },
  async (span) => {
    try {
      const response = await fetch(
        `${API_URL}/api/search?${new URLSearchParams({ q: searchQuery })}`,
        {
          signal: controller.signal,
          headers: { 'Content-Type': 'application/json' },
        }
      );

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({}));
        const errorMessage = errorData.error || `Search failed: ${response.status}`;
        throw new Error(errorMessage);
      }

      const data: SearchResponse = await response.json();
      
      span?.setAttribute('results.count', data.results.length);
      span?.setAttribute('results.has_results', data.results.length > 0);
      span?.setAttribute('http.response_size', JSON.stringify(data).length);
      span?.setStatus({ code: 1, message: 'ok' });
      
      return data;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        span?.setAttribute('ui.aborted', true);
        span?.setStatus({ code: 2, message: 'cancelled' });
        throw error;
      }
      
      span?.setStatus({ code: 2, message: error instanceof Error ? error.message : 'unknown error' });
      throw error;
    }
  }
);
```

Where to put this in your app:
- In your search input component, triggered after debounce timeout

**Backend (Node.js + Express) — instrument search with meaningful attributes:**

```typescript
app.get('/api/search', async (req: Request, res: Response) => {
  await Sentry.startSpan(
    {
      name: 'Search',
      op: 'search',
    },
    async (span) => {
      try {
        const query = String(req.query.q || '');
        const queryLength = query.length;
        
        // Check if request was aborted
        req.on('close', () => {
          if (!res.headersSent) {
            span?.setStatus({ code: 2, message: 'cancelled' });
            span?.setAttribute('request.aborted', true);
          }
        });
        
        if (!query) {
          span?.setAttribute('results.count', 0);
          span?.setAttribute('search.engine', 'elasticsearch');
          return res.json({ results: [] });
        }
        
        // Perform search
        const startSearch = Date.now();
        const results = await searchMovies(query);
        const searchDuration = Date.now() - startSearch;
        
        // Set span attributes
        span?.setAttribute('search.engine', 'elasticsearch');
        span?.setAttribute('search.mode', queryLength < 3 ? 'prefix' : 'fuzzy');
        span?.setAttribute('results.count', results.length);
        span?.setAttribute('query.length', queryLength);
        
        // Track slow searches
        if (searchDuration > 500) {
          span?.setAttribute('performance.slow', true);
          span?.setAttribute('search.duration_ms', searchDuration);
        }
        
        return res.json({ results });
      } catch (error: any) {
        span?.setStatus({ code: 2, message: error?.message || 'error' });
        span?.setAttribute('error.type', (error as any)?.constructor?.name || 'Error');
        
        Sentry.captureException(error);
        if (!res.headersSent) {
          return res.status(500).json({ error: 'Search failed' });
        }
      }
    }
  );
});
```

**How the trace works together:**
- Client span starts when debounced search triggers → tracks the full user-perceived latency.
- Aborted requests are marked with `ui.aborted=true` and short duration, showing wasted work.
- Server span shows search performance characteristics: mode (prefix vs fuzzy), results count, and slow queries.

What to monitor with span metrics:
- p95 duration of `op:search` grouped by `query.length`.
- Characteristics of slow searches via `op:search performance.slow:true`.
- Compare prefix vs fuzzy via `op:search` grouped by `search.mode`.
- Cancellation rate via `op:http.client ui.aborted:true`.
- Empty result rate via `op:http.client results.has_results:false`.
- Distribution of `http.response_size` for payload optimization.
- Error rate for `op:search` filtered by `status:error`.
- Backend abandonment via `op:search request.aborted:true`.
